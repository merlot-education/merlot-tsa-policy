// Code generated by counterfeiter. DO NOT EDIT.
package regofuncfakes

import (
	"context"
	"sync"

	"gitlab.eclipse.org/eclipse/xfsc/tsa/policy/internal/regofunc"
)

type FakeStorage struct {
	DeleteDataStub        func(context.Context, string) error
	deleteDataMutex       sync.RWMutex
	deleteDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteDataReturns struct {
		result1 error
	}
	deleteDataReturnsOnCall map[int]struct {
		result1 error
	}
	GetDataStub        func(context.Context, string) (any, error)
	getDataMutex       sync.RWMutex
	getDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDataReturns struct {
		result1 any
		result2 error
	}
	getDataReturnsOnCall map[int]struct {
		result1 any
		result2 error
	}
	SetDataStub        func(context.Context, string, map[string]interface{}) error
	setDataMutex       sync.RWMutex
	setDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}
	setDataReturns struct {
		result1 error
	}
	setDataReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) DeleteData(arg1 context.Context, arg2 string) error {
	fake.deleteDataMutex.Lock()
	ret, specificReturn := fake.deleteDataReturnsOnCall[len(fake.deleteDataArgsForCall)]
	fake.deleteDataArgsForCall = append(fake.deleteDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteDataStub
	fakeReturns := fake.deleteDataReturns
	fake.recordInvocation("DeleteData", []interface{}{arg1, arg2})
	fake.deleteDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteDataCallCount() int {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	return len(fake.deleteDataArgsForCall)
}

func (fake *FakeStorage) DeleteDataCalls(stub func(context.Context, string) error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = stub
}

func (fake *FakeStorage) DeleteDataArgsForCall(i int) (context.Context, string) {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	argsForCall := fake.deleteDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) DeleteDataReturns(result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	fake.deleteDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteDataReturnsOnCall(i int, result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	if fake.deleteDataReturnsOnCall == nil {
		fake.deleteDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) GetData(arg1 context.Context, arg2 string) (any, error) {
	fake.getDataMutex.Lock()
	ret, specificReturn := fake.getDataReturnsOnCall[len(fake.getDataArgsForCall)]
	fake.getDataArgsForCall = append(fake.getDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDataStub
	fakeReturns := fake.getDataReturns
	fake.recordInvocation("GetData", []interface{}{arg1, arg2})
	fake.getDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetDataCallCount() int {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	return len(fake.getDataArgsForCall)
}

func (fake *FakeStorage) GetDataCalls(stub func(context.Context, string) (any, error)) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = stub
}

func (fake *FakeStorage) GetDataArgsForCall(i int) (context.Context, string) {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	argsForCall := fake.getDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetDataReturns(result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	fake.getDataReturns = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetDataReturnsOnCall(i int, result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	if fake.getDataReturnsOnCall == nil {
		fake.getDataReturnsOnCall = make(map[int]struct {
			result1 any
			result2 error
		})
	}
	fake.getDataReturnsOnCall[i] = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) SetData(arg1 context.Context, arg2 string, arg3 map[string]interface{}) error {
	fake.setDataMutex.Lock()
	ret, specificReturn := fake.setDataReturnsOnCall[len(fake.setDataArgsForCall)]
	fake.setDataArgsForCall = append(fake.setDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.SetDataStub
	fakeReturns := fake.setDataReturns
	fake.recordInvocation("SetData", []interface{}{arg1, arg2, arg3})
	fake.setDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SetDataCallCount() int {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	return len(fake.setDataArgsForCall)
}

func (fake *FakeStorage) SetDataCalls(stub func(context.Context, string, map[string]interface{}) error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = stub
}

func (fake *FakeStorage) SetDataArgsForCall(i int) (context.Context, string, map[string]interface{}) {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	argsForCall := fake.setDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) SetDataReturns(result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	fake.setDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetDataReturnsOnCall(i int, result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	if fake.setDataReturnsOnCall == nil {
		fake.setDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ regofunc.Storage = new(FakeStorage)
