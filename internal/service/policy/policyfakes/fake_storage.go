// Code generated by counterfeiter. DO NOT EDIT.
package policyfakes

import (
	"context"
	"sync"

	"gitlab.eclipse.org/eclipse/xfsc/tsa/policy/internal/service/policy"
	"gitlab.eclipse.org/eclipse/xfsc/tsa/policy/internal/storage"
)

type FakeStorage struct {
	AddPolicyChangeSubscribersStub        func(...storage.PolicyChangeSubscriber)
	addPolicyChangeSubscribersMutex       sync.RWMutex
	addPolicyChangeSubscribersArgsForCall []struct {
		arg1 []storage.PolicyChangeSubscriber
	}
	CloseStub        func(context.Context)
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		arg1 context.Context
	}
	CreateSubscriberStub        func(context.Context, *storage.Subscriber) (*storage.Subscriber, error)
	createSubscriberMutex       sync.RWMutex
	createSubscriberArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.Subscriber
	}
	createSubscriberReturns struct {
		result1 *storage.Subscriber
		result2 error
	}
	createSubscriberReturnsOnCall map[int]struct {
		result1 *storage.Subscriber
		result2 error
	}
	DeleteDataStub        func(context.Context, string) error
	deleteDataMutex       sync.RWMutex
	deleteDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteDataReturns struct {
		result1 error
	}
	deleteDataReturnsOnCall map[int]struct {
		result1 error
	}
	GetDataStub        func(context.Context, string) (any, error)
	getDataMutex       sync.RWMutex
	getDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDataReturns struct {
		result1 any
		result2 error
	}
	getDataReturnsOnCall map[int]struct {
		result1 any
		result2 error
	}
	GetPoliciesStub        func(context.Context, *bool) ([]*storage.Policy, error)
	getPoliciesMutex       sync.RWMutex
	getPoliciesArgsForCall []struct {
		arg1 context.Context
		arg2 *bool
	}
	getPoliciesReturns struct {
		result1 []*storage.Policy
		result2 error
	}
	getPoliciesReturnsOnCall map[int]struct {
		result1 []*storage.Policy
		result2 error
	}
	ListenPolicyDataChangesStub        func(context.Context) error
	listenPolicyDataChangesMutex       sync.RWMutex
	listenPolicyDataChangesArgsForCall []struct {
		arg1 context.Context
	}
	listenPolicyDataChangesReturns struct {
		result1 error
	}
	listenPolicyDataChangesReturnsOnCall map[int]struct {
		result1 error
	}
	PolicyStub        func(context.Context, string, string, string, string) (*storage.Policy, error)
	policyMutex       sync.RWMutex
	policyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	policyReturns struct {
		result1 *storage.Policy
		result2 error
	}
	policyReturnsOnCall map[int]struct {
		result1 *storage.Policy
		result2 error
	}
	SetDataStub        func(context.Context, string, map[string]interface{}) error
	setDataMutex       sync.RWMutex
	setDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}
	setDataReturns struct {
		result1 error
	}
	setDataReturnsOnCall map[int]struct {
		result1 error
	}
	SetPolicyLockStub        func(context.Context, string, string, string, string, bool) error
	setPolicyLockMutex       sync.RWMutex
	setPolicyLockArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 bool
	}
	setPolicyLockReturns struct {
		result1 error
	}
	setPolicyLockReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) AddPolicyChangeSubscribers(arg1 ...storage.PolicyChangeSubscriber) {
	fake.addPolicyChangeSubscribersMutex.Lock()
	fake.addPolicyChangeSubscribersArgsForCall = append(fake.addPolicyChangeSubscribersArgsForCall, struct {
		arg1 []storage.PolicyChangeSubscriber
	}{arg1})
	stub := fake.AddPolicyChangeSubscribersStub
	fake.recordInvocation("AddPolicyChangeSubscribers", []interface{}{arg1})
	fake.addPolicyChangeSubscribersMutex.Unlock()
	if stub != nil {
		fake.AddPolicyChangeSubscribersStub(arg1...)
	}
}

func (fake *FakeStorage) AddPolicyChangeSubscribersCallCount() int {
	fake.addPolicyChangeSubscribersMutex.RLock()
	defer fake.addPolicyChangeSubscribersMutex.RUnlock()
	return len(fake.addPolicyChangeSubscribersArgsForCall)
}

func (fake *FakeStorage) AddPolicyChangeSubscribersCalls(stub func(...storage.PolicyChangeSubscriber)) {
	fake.addPolicyChangeSubscribersMutex.Lock()
	defer fake.addPolicyChangeSubscribersMutex.Unlock()
	fake.AddPolicyChangeSubscribersStub = stub
}

func (fake *FakeStorage) AddPolicyChangeSubscribersArgsForCall(i int) []storage.PolicyChangeSubscriber {
	fake.addPolicyChangeSubscribersMutex.RLock()
	defer fake.addPolicyChangeSubscribersMutex.RUnlock()
	argsForCall := fake.addPolicyChangeSubscribersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) Close(arg1 context.Context) {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{arg1})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub(arg1)
	}
}

func (fake *FakeStorage) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeStorage) CloseCalls(stub func(context.Context)) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeStorage) CloseArgsForCall(i int) context.Context {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	argsForCall := fake.closeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) CreateSubscriber(arg1 context.Context, arg2 *storage.Subscriber) (*storage.Subscriber, error) {
	fake.createSubscriberMutex.Lock()
	ret, specificReturn := fake.createSubscriberReturnsOnCall[len(fake.createSubscriberArgsForCall)]
	fake.createSubscriberArgsForCall = append(fake.createSubscriberArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.Subscriber
	}{arg1, arg2})
	stub := fake.CreateSubscriberStub
	fakeReturns := fake.createSubscriberReturns
	fake.recordInvocation("CreateSubscriber", []interface{}{arg1, arg2})
	fake.createSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) CreateSubscriberCallCount() int {
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	return len(fake.createSubscriberArgsForCall)
}

func (fake *FakeStorage) CreateSubscriberCalls(stub func(context.Context, *storage.Subscriber) (*storage.Subscriber, error)) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = stub
}

func (fake *FakeStorage) CreateSubscriberArgsForCall(i int) (context.Context, *storage.Subscriber) {
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	argsForCall := fake.createSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) CreateSubscriberReturns(result1 *storage.Subscriber, result2 error) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = nil
	fake.createSubscriberReturns = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) CreateSubscriberReturnsOnCall(i int, result1 *storage.Subscriber, result2 error) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = nil
	if fake.createSubscriberReturnsOnCall == nil {
		fake.createSubscriberReturnsOnCall = make(map[int]struct {
			result1 *storage.Subscriber
			result2 error
		})
	}
	fake.createSubscriberReturnsOnCall[i] = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) DeleteData(arg1 context.Context, arg2 string) error {
	fake.deleteDataMutex.Lock()
	ret, specificReturn := fake.deleteDataReturnsOnCall[len(fake.deleteDataArgsForCall)]
	fake.deleteDataArgsForCall = append(fake.deleteDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteDataStub
	fakeReturns := fake.deleteDataReturns
	fake.recordInvocation("DeleteData", []interface{}{arg1, arg2})
	fake.deleteDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteDataCallCount() int {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	return len(fake.deleteDataArgsForCall)
}

func (fake *FakeStorage) DeleteDataCalls(stub func(context.Context, string) error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = stub
}

func (fake *FakeStorage) DeleteDataArgsForCall(i int) (context.Context, string) {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	argsForCall := fake.deleteDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) DeleteDataReturns(result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	fake.deleteDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteDataReturnsOnCall(i int, result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	if fake.deleteDataReturnsOnCall == nil {
		fake.deleteDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) GetData(arg1 context.Context, arg2 string) (any, error) {
	fake.getDataMutex.Lock()
	ret, specificReturn := fake.getDataReturnsOnCall[len(fake.getDataArgsForCall)]
	fake.getDataArgsForCall = append(fake.getDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDataStub
	fakeReturns := fake.getDataReturns
	fake.recordInvocation("GetData", []interface{}{arg1, arg2})
	fake.getDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetDataCallCount() int {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	return len(fake.getDataArgsForCall)
}

func (fake *FakeStorage) GetDataCalls(stub func(context.Context, string) (any, error)) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = stub
}

func (fake *FakeStorage) GetDataArgsForCall(i int) (context.Context, string) {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	argsForCall := fake.getDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetDataReturns(result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	fake.getDataReturns = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetDataReturnsOnCall(i int, result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	if fake.getDataReturnsOnCall == nil {
		fake.getDataReturnsOnCall = make(map[int]struct {
			result1 any
			result2 error
		})
	}
	fake.getDataReturnsOnCall[i] = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetPolicies(arg1 context.Context, arg2 *bool) ([]*storage.Policy, error) {
	fake.getPoliciesMutex.Lock()
	ret, specificReturn := fake.getPoliciesReturnsOnCall[len(fake.getPoliciesArgsForCall)]
	fake.getPoliciesArgsForCall = append(fake.getPoliciesArgsForCall, struct {
		arg1 context.Context
		arg2 *bool
	}{arg1, arg2})
	stub := fake.GetPoliciesStub
	fakeReturns := fake.getPoliciesReturns
	fake.recordInvocation("GetPolicies", []interface{}{arg1, arg2})
	fake.getPoliciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetPoliciesCallCount() int {
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	return len(fake.getPoliciesArgsForCall)
}

func (fake *FakeStorage) GetPoliciesCalls(stub func(context.Context, *bool) ([]*storage.Policy, error)) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = stub
}

func (fake *FakeStorage) GetPoliciesArgsForCall(i int) (context.Context, *bool) {
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	argsForCall := fake.getPoliciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetPoliciesReturns(result1 []*storage.Policy, result2 error) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = nil
	fake.getPoliciesReturns = struct {
		result1 []*storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetPoliciesReturnsOnCall(i int, result1 []*storage.Policy, result2 error) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = nil
	if fake.getPoliciesReturnsOnCall == nil {
		fake.getPoliciesReturnsOnCall = make(map[int]struct {
			result1 []*storage.Policy
			result2 error
		})
	}
	fake.getPoliciesReturnsOnCall[i] = struct {
		result1 []*storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListenPolicyDataChanges(arg1 context.Context) error {
	fake.listenPolicyDataChangesMutex.Lock()
	ret, specificReturn := fake.listenPolicyDataChangesReturnsOnCall[len(fake.listenPolicyDataChangesArgsForCall)]
	fake.listenPolicyDataChangesArgsForCall = append(fake.listenPolicyDataChangesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListenPolicyDataChangesStub
	fakeReturns := fake.listenPolicyDataChangesReturns
	fake.recordInvocation("ListenPolicyDataChanges", []interface{}{arg1})
	fake.listenPolicyDataChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) ListenPolicyDataChangesCallCount() int {
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	return len(fake.listenPolicyDataChangesArgsForCall)
}

func (fake *FakeStorage) ListenPolicyDataChangesCalls(stub func(context.Context) error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = stub
}

func (fake *FakeStorage) ListenPolicyDataChangesArgsForCall(i int) context.Context {
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	argsForCall := fake.listenPolicyDataChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) ListenPolicyDataChangesReturns(result1 error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = nil
	fake.listenPolicyDataChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) ListenPolicyDataChangesReturnsOnCall(i int, result1 error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = nil
	if fake.listenPolicyDataChangesReturnsOnCall == nil {
		fake.listenPolicyDataChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenPolicyDataChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Policy(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) (*storage.Policy, error) {
	fake.policyMutex.Lock()
	ret, specificReturn := fake.policyReturnsOnCall[len(fake.policyArgsForCall)]
	fake.policyArgsForCall = append(fake.policyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.PolicyStub
	fakeReturns := fake.policyReturns
	fake.recordInvocation("Policy", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.policyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) PolicyCallCount() int {
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	return len(fake.policyArgsForCall)
}

func (fake *FakeStorage) PolicyCalls(stub func(context.Context, string, string, string, string) (*storage.Policy, error)) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = stub
}

func (fake *FakeStorage) PolicyArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	argsForCall := fake.policyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStorage) PolicyReturns(result1 *storage.Policy, result2 error) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = nil
	fake.policyReturns = struct {
		result1 *storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) PolicyReturnsOnCall(i int, result1 *storage.Policy, result2 error) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = nil
	if fake.policyReturnsOnCall == nil {
		fake.policyReturnsOnCall = make(map[int]struct {
			result1 *storage.Policy
			result2 error
		})
	}
	fake.policyReturnsOnCall[i] = struct {
		result1 *storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) SetData(arg1 context.Context, arg2 string, arg3 map[string]interface{}) error {
	fake.setDataMutex.Lock()
	ret, specificReturn := fake.setDataReturnsOnCall[len(fake.setDataArgsForCall)]
	fake.setDataArgsForCall = append(fake.setDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.SetDataStub
	fakeReturns := fake.setDataReturns
	fake.recordInvocation("SetData", []interface{}{arg1, arg2, arg3})
	fake.setDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SetDataCallCount() int {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	return len(fake.setDataArgsForCall)
}

func (fake *FakeStorage) SetDataCalls(stub func(context.Context, string, map[string]interface{}) error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = stub
}

func (fake *FakeStorage) SetDataArgsForCall(i int) (context.Context, string, map[string]interface{}) {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	argsForCall := fake.setDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) SetDataReturns(result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	fake.setDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetDataReturnsOnCall(i int, result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	if fake.setDataReturnsOnCall == nil {
		fake.setDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetPolicyLock(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 bool) error {
	fake.setPolicyLockMutex.Lock()
	ret, specificReturn := fake.setPolicyLockReturnsOnCall[len(fake.setPolicyLockArgsForCall)]
	fake.setPolicyLockArgsForCall = append(fake.setPolicyLockArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.SetPolicyLockStub
	fakeReturns := fake.setPolicyLockReturns
	fake.recordInvocation("SetPolicyLock", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.setPolicyLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SetPolicyLockCallCount() int {
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	return len(fake.setPolicyLockArgsForCall)
}

func (fake *FakeStorage) SetPolicyLockCalls(stub func(context.Context, string, string, string, string, bool) error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = stub
}

func (fake *FakeStorage) SetPolicyLockArgsForCall(i int) (context.Context, string, string, string, string, bool) {
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	argsForCall := fake.setPolicyLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStorage) SetPolicyLockReturns(result1 error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = nil
	fake.setPolicyLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetPolicyLockReturnsOnCall(i int, result1 error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = nil
	if fake.setPolicyLockReturnsOnCall == nil {
		fake.setPolicyLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPolicyLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addPolicyChangeSubscribersMutex.RLock()
	defer fake.addPolicyChangeSubscribersMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ policy.Storage = new(FakeStorage)
