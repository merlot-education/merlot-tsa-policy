// Code generated by counterfeiter. DO NOT EDIT.
package policyfakes

import (
	"context"
	"sync"

	"gitlab.eclipse.org/eclipse/xfsc/tsa/policy/internal/service/policy"
	"gitlab.eclipse.org/eclipse/xfsc/tsa/policy/internal/storage"
)

type FakeStorage struct {
	ActiveImportConfigsStub        func(context.Context) ([]*storage.PolicyAutoImport, error)
	activeImportConfigsMutex       sync.RWMutex
	activeImportConfigsArgsForCall []struct {
		arg1 context.Context
	}
	activeImportConfigsReturns struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}
	activeImportConfigsReturnsOnCall map[int]struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}
	AddPolicySubscribersStub        func(...storage.PolicySubscriber)
	addPolicySubscribersMutex       sync.RWMutex
	addPolicySubscribersArgsForCall []struct {
		arg1 []storage.PolicySubscriber
	}
	AutoImportConfigStub        func(context.Context, string) (*storage.PolicyAutoImport, error)
	autoImportConfigMutex       sync.RWMutex
	autoImportConfigArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	autoImportConfigReturns struct {
		result1 *storage.PolicyAutoImport
		result2 error
	}
	autoImportConfigReturnsOnCall map[int]struct {
		result1 *storage.PolicyAutoImport
		result2 error
	}
	AutoImportConfigsStub        func(context.Context) ([]*storage.PolicyAutoImport, error)
	autoImportConfigsMutex       sync.RWMutex
	autoImportConfigsArgsForCall []struct {
		arg1 context.Context
	}
	autoImportConfigsReturns struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}
	autoImportConfigsReturnsOnCall map[int]struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}
	CloseStub        func(context.Context)
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
		arg1 context.Context
	}
	CreateSubscriberStub        func(context.Context, *storage.Subscriber) (*storage.Subscriber, error)
	createSubscriberMutex       sync.RWMutex
	createSubscriberArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.Subscriber
	}
	createSubscriberReturns struct {
		result1 *storage.Subscriber
		result2 error
	}
	createSubscriberReturnsOnCall map[int]struct {
		result1 *storage.Subscriber
		result2 error
	}
	DeleteAutoImportConfigStub        func(context.Context, string) error
	deleteAutoImportConfigMutex       sync.RWMutex
	deleteAutoImportConfigArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteAutoImportConfigReturns struct {
		result1 error
	}
	deleteAutoImportConfigReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteDataStub        func(context.Context, string) error
	deleteDataMutex       sync.RWMutex
	deleteDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteDataReturns struct {
		result1 error
	}
	deleteDataReturnsOnCall map[int]struct {
		result1 error
	}
	GetDataStub        func(context.Context, string) (any, error)
	getDataMutex       sync.RWMutex
	getDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	getDataReturns struct {
		result1 any
		result2 error
	}
	getDataReturnsOnCall map[int]struct {
		result1 any
		result2 error
	}
	GetPoliciesStub        func(context.Context, *bool) ([]*storage.Policy, error)
	getPoliciesMutex       sync.RWMutex
	getPoliciesArgsForCall []struct {
		arg1 context.Context
		arg2 *bool
	}
	getPoliciesReturns struct {
		result1 []*storage.Policy
		result2 error
	}
	getPoliciesReturnsOnCall map[int]struct {
		result1 []*storage.Policy
		result2 error
	}
	ListenPolicyDataChangesStub        func(context.Context) error
	listenPolicyDataChangesMutex       sync.RWMutex
	listenPolicyDataChangesArgsForCall []struct {
		arg1 context.Context
	}
	listenPolicyDataChangesReturns struct {
		result1 error
	}
	listenPolicyDataChangesReturnsOnCall map[int]struct {
		result1 error
	}
	PolicyStub        func(context.Context, string, string, string, string) (*storage.Policy, error)
	policyMutex       sync.RWMutex
	policyArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}
	policyReturns struct {
		result1 *storage.Policy
		result2 error
	}
	policyReturnsOnCall map[int]struct {
		result1 *storage.Policy
		result2 error
	}
	SaveAutoImportConfigStub        func(context.Context, *storage.PolicyAutoImport) error
	saveAutoImportConfigMutex       sync.RWMutex
	saveAutoImportConfigArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.PolicyAutoImport
	}
	saveAutoImportConfigReturns struct {
		result1 error
	}
	saveAutoImportConfigReturnsOnCall map[int]struct {
		result1 error
	}
	SavePolicyStub        func(context.Context, *storage.Policy) error
	savePolicyMutex       sync.RWMutex
	savePolicyArgsForCall []struct {
		arg1 context.Context
		arg2 *storage.Policy
	}
	savePolicyReturns struct {
		result1 error
	}
	savePolicyReturnsOnCall map[int]struct {
		result1 error
	}
	SetDataStub        func(context.Context, string, map[string]interface{}) error
	setDataMutex       sync.RWMutex
	setDataArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}
	setDataReturns struct {
		result1 error
	}
	setDataReturnsOnCall map[int]struct {
		result1 error
	}
	SetPolicyLockStub        func(context.Context, string, string, string, string, bool) error
	setPolicyLockMutex       sync.RWMutex
	setPolicyLockArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 bool
	}
	setPolicyLockReturns struct {
		result1 error
	}
	setPolicyLockReturnsOnCall map[int]struct {
		result1 error
	}
	SubscriberStub        func(context.Context, string, string, string, string, string, string) (*storage.Subscriber, error)
	subscriberMutex       sync.RWMutex
	subscriberArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}
	subscriberReturns struct {
		result1 *storage.Subscriber
		result2 error
	}
	subscriberReturnsOnCall map[int]struct {
		result1 *storage.Subscriber
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStorage) ActiveImportConfigs(arg1 context.Context) ([]*storage.PolicyAutoImport, error) {
	fake.activeImportConfigsMutex.Lock()
	ret, specificReturn := fake.activeImportConfigsReturnsOnCall[len(fake.activeImportConfigsArgsForCall)]
	fake.activeImportConfigsArgsForCall = append(fake.activeImportConfigsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ActiveImportConfigsStub
	fakeReturns := fake.activeImportConfigsReturns
	fake.recordInvocation("ActiveImportConfigs", []interface{}{arg1})
	fake.activeImportConfigsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) ActiveImportConfigsCallCount() int {
	fake.activeImportConfigsMutex.RLock()
	defer fake.activeImportConfigsMutex.RUnlock()
	return len(fake.activeImportConfigsArgsForCall)
}

func (fake *FakeStorage) ActiveImportConfigsCalls(stub func(context.Context) ([]*storage.PolicyAutoImport, error)) {
	fake.activeImportConfigsMutex.Lock()
	defer fake.activeImportConfigsMutex.Unlock()
	fake.ActiveImportConfigsStub = stub
}

func (fake *FakeStorage) ActiveImportConfigsArgsForCall(i int) context.Context {
	fake.activeImportConfigsMutex.RLock()
	defer fake.activeImportConfigsMutex.RUnlock()
	argsForCall := fake.activeImportConfigsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) ActiveImportConfigsReturns(result1 []*storage.PolicyAutoImport, result2 error) {
	fake.activeImportConfigsMutex.Lock()
	defer fake.activeImportConfigsMutex.Unlock()
	fake.ActiveImportConfigsStub = nil
	fake.activeImportConfigsReturns = struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ActiveImportConfigsReturnsOnCall(i int, result1 []*storage.PolicyAutoImport, result2 error) {
	fake.activeImportConfigsMutex.Lock()
	defer fake.activeImportConfigsMutex.Unlock()
	fake.ActiveImportConfigsStub = nil
	if fake.activeImportConfigsReturnsOnCall == nil {
		fake.activeImportConfigsReturnsOnCall = make(map[int]struct {
			result1 []*storage.PolicyAutoImport
			result2 error
		})
	}
	fake.activeImportConfigsReturnsOnCall[i] = struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) AddPolicySubscribers(arg1 ...storage.PolicySubscriber) {
	fake.addPolicySubscribersMutex.Lock()
	fake.addPolicySubscribersArgsForCall = append(fake.addPolicySubscribersArgsForCall, struct {
		arg1 []storage.PolicySubscriber
	}{arg1})
	stub := fake.AddPolicySubscribersStub
	fake.recordInvocation("AddPolicySubscribers", []interface{}{arg1})
	fake.addPolicySubscribersMutex.Unlock()
	if stub != nil {
		fake.AddPolicySubscribersStub(arg1...)
	}
}

func (fake *FakeStorage) AddPolicySubscribersCallCount() int {
	fake.addPolicySubscribersMutex.RLock()
	defer fake.addPolicySubscribersMutex.RUnlock()
	return len(fake.addPolicySubscribersArgsForCall)
}

func (fake *FakeStorage) AddPolicySubscribersCalls(stub func(...storage.PolicySubscriber)) {
	fake.addPolicySubscribersMutex.Lock()
	defer fake.addPolicySubscribersMutex.Unlock()
	fake.AddPolicySubscribersStub = stub
}

func (fake *FakeStorage) AddPolicySubscribersArgsForCall(i int) []storage.PolicySubscriber {
	fake.addPolicySubscribersMutex.RLock()
	defer fake.addPolicySubscribersMutex.RUnlock()
	argsForCall := fake.addPolicySubscribersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) AutoImportConfig(arg1 context.Context, arg2 string) (*storage.PolicyAutoImport, error) {
	fake.autoImportConfigMutex.Lock()
	ret, specificReturn := fake.autoImportConfigReturnsOnCall[len(fake.autoImportConfigArgsForCall)]
	fake.autoImportConfigArgsForCall = append(fake.autoImportConfigArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.AutoImportConfigStub
	fakeReturns := fake.autoImportConfigReturns
	fake.recordInvocation("AutoImportConfig", []interface{}{arg1, arg2})
	fake.autoImportConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) AutoImportConfigCallCount() int {
	fake.autoImportConfigMutex.RLock()
	defer fake.autoImportConfigMutex.RUnlock()
	return len(fake.autoImportConfigArgsForCall)
}

func (fake *FakeStorage) AutoImportConfigCalls(stub func(context.Context, string) (*storage.PolicyAutoImport, error)) {
	fake.autoImportConfigMutex.Lock()
	defer fake.autoImportConfigMutex.Unlock()
	fake.AutoImportConfigStub = stub
}

func (fake *FakeStorage) AutoImportConfigArgsForCall(i int) (context.Context, string) {
	fake.autoImportConfigMutex.RLock()
	defer fake.autoImportConfigMutex.RUnlock()
	argsForCall := fake.autoImportConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) AutoImportConfigReturns(result1 *storage.PolicyAutoImport, result2 error) {
	fake.autoImportConfigMutex.Lock()
	defer fake.autoImportConfigMutex.Unlock()
	fake.AutoImportConfigStub = nil
	fake.autoImportConfigReturns = struct {
		result1 *storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) AutoImportConfigReturnsOnCall(i int, result1 *storage.PolicyAutoImport, result2 error) {
	fake.autoImportConfigMutex.Lock()
	defer fake.autoImportConfigMutex.Unlock()
	fake.AutoImportConfigStub = nil
	if fake.autoImportConfigReturnsOnCall == nil {
		fake.autoImportConfigReturnsOnCall = make(map[int]struct {
			result1 *storage.PolicyAutoImport
			result2 error
		})
	}
	fake.autoImportConfigReturnsOnCall[i] = struct {
		result1 *storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) AutoImportConfigs(arg1 context.Context) ([]*storage.PolicyAutoImport, error) {
	fake.autoImportConfigsMutex.Lock()
	ret, specificReturn := fake.autoImportConfigsReturnsOnCall[len(fake.autoImportConfigsArgsForCall)]
	fake.autoImportConfigsArgsForCall = append(fake.autoImportConfigsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.AutoImportConfigsStub
	fakeReturns := fake.autoImportConfigsReturns
	fake.recordInvocation("AutoImportConfigs", []interface{}{arg1})
	fake.autoImportConfigsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) AutoImportConfigsCallCount() int {
	fake.autoImportConfigsMutex.RLock()
	defer fake.autoImportConfigsMutex.RUnlock()
	return len(fake.autoImportConfigsArgsForCall)
}

func (fake *FakeStorage) AutoImportConfigsCalls(stub func(context.Context) ([]*storage.PolicyAutoImport, error)) {
	fake.autoImportConfigsMutex.Lock()
	defer fake.autoImportConfigsMutex.Unlock()
	fake.AutoImportConfigsStub = stub
}

func (fake *FakeStorage) AutoImportConfigsArgsForCall(i int) context.Context {
	fake.autoImportConfigsMutex.RLock()
	defer fake.autoImportConfigsMutex.RUnlock()
	argsForCall := fake.autoImportConfigsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) AutoImportConfigsReturns(result1 []*storage.PolicyAutoImport, result2 error) {
	fake.autoImportConfigsMutex.Lock()
	defer fake.autoImportConfigsMutex.Unlock()
	fake.AutoImportConfigsStub = nil
	fake.autoImportConfigsReturns = struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) AutoImportConfigsReturnsOnCall(i int, result1 []*storage.PolicyAutoImport, result2 error) {
	fake.autoImportConfigsMutex.Lock()
	defer fake.autoImportConfigsMutex.Unlock()
	fake.AutoImportConfigsStub = nil
	if fake.autoImportConfigsReturnsOnCall == nil {
		fake.autoImportConfigsReturnsOnCall = make(map[int]struct {
			result1 []*storage.PolicyAutoImport
			result2 error
		})
	}
	fake.autoImportConfigsReturnsOnCall[i] = struct {
		result1 []*storage.PolicyAutoImport
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Close(arg1 context.Context) {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.CloseStub
	fake.recordInvocation("Close", []interface{}{arg1})
	fake.closeMutex.Unlock()
	if stub != nil {
		fake.CloseStub(arg1)
	}
}

func (fake *FakeStorage) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeStorage) CloseCalls(stub func(context.Context)) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeStorage) CloseArgsForCall(i int) context.Context {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	argsForCall := fake.closeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) CreateSubscriber(arg1 context.Context, arg2 *storage.Subscriber) (*storage.Subscriber, error) {
	fake.createSubscriberMutex.Lock()
	ret, specificReturn := fake.createSubscriberReturnsOnCall[len(fake.createSubscriberArgsForCall)]
	fake.createSubscriberArgsForCall = append(fake.createSubscriberArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.Subscriber
	}{arg1, arg2})
	stub := fake.CreateSubscriberStub
	fakeReturns := fake.createSubscriberReturns
	fake.recordInvocation("CreateSubscriber", []interface{}{arg1, arg2})
	fake.createSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) CreateSubscriberCallCount() int {
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	return len(fake.createSubscriberArgsForCall)
}

func (fake *FakeStorage) CreateSubscriberCalls(stub func(context.Context, *storage.Subscriber) (*storage.Subscriber, error)) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = stub
}

func (fake *FakeStorage) CreateSubscriberArgsForCall(i int) (context.Context, *storage.Subscriber) {
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	argsForCall := fake.createSubscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) CreateSubscriberReturns(result1 *storage.Subscriber, result2 error) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = nil
	fake.createSubscriberReturns = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) CreateSubscriberReturnsOnCall(i int, result1 *storage.Subscriber, result2 error) {
	fake.createSubscriberMutex.Lock()
	defer fake.createSubscriberMutex.Unlock()
	fake.CreateSubscriberStub = nil
	if fake.createSubscriberReturnsOnCall == nil {
		fake.createSubscriberReturnsOnCall = make(map[int]struct {
			result1 *storage.Subscriber
			result2 error
		})
	}
	fake.createSubscriberReturnsOnCall[i] = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) DeleteAutoImportConfig(arg1 context.Context, arg2 string) error {
	fake.deleteAutoImportConfigMutex.Lock()
	ret, specificReturn := fake.deleteAutoImportConfigReturnsOnCall[len(fake.deleteAutoImportConfigArgsForCall)]
	fake.deleteAutoImportConfigArgsForCall = append(fake.deleteAutoImportConfigArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteAutoImportConfigStub
	fakeReturns := fake.deleteAutoImportConfigReturns
	fake.recordInvocation("DeleteAutoImportConfig", []interface{}{arg1, arg2})
	fake.deleteAutoImportConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteAutoImportConfigCallCount() int {
	fake.deleteAutoImportConfigMutex.RLock()
	defer fake.deleteAutoImportConfigMutex.RUnlock()
	return len(fake.deleteAutoImportConfigArgsForCall)
}

func (fake *FakeStorage) DeleteAutoImportConfigCalls(stub func(context.Context, string) error) {
	fake.deleteAutoImportConfigMutex.Lock()
	defer fake.deleteAutoImportConfigMutex.Unlock()
	fake.DeleteAutoImportConfigStub = stub
}

func (fake *FakeStorage) DeleteAutoImportConfigArgsForCall(i int) (context.Context, string) {
	fake.deleteAutoImportConfigMutex.RLock()
	defer fake.deleteAutoImportConfigMutex.RUnlock()
	argsForCall := fake.deleteAutoImportConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) DeleteAutoImportConfigReturns(result1 error) {
	fake.deleteAutoImportConfigMutex.Lock()
	defer fake.deleteAutoImportConfigMutex.Unlock()
	fake.DeleteAutoImportConfigStub = nil
	fake.deleteAutoImportConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteAutoImportConfigReturnsOnCall(i int, result1 error) {
	fake.deleteAutoImportConfigMutex.Lock()
	defer fake.deleteAutoImportConfigMutex.Unlock()
	fake.DeleteAutoImportConfigStub = nil
	if fake.deleteAutoImportConfigReturnsOnCall == nil {
		fake.deleteAutoImportConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteAutoImportConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteData(arg1 context.Context, arg2 string) error {
	fake.deleteDataMutex.Lock()
	ret, specificReturn := fake.deleteDataReturnsOnCall[len(fake.deleteDataArgsForCall)]
	fake.deleteDataArgsForCall = append(fake.deleteDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteDataStub
	fakeReturns := fake.deleteDataReturns
	fake.recordInvocation("DeleteData", []interface{}{arg1, arg2})
	fake.deleteDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) DeleteDataCallCount() int {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	return len(fake.deleteDataArgsForCall)
}

func (fake *FakeStorage) DeleteDataCalls(stub func(context.Context, string) error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = stub
}

func (fake *FakeStorage) DeleteDataArgsForCall(i int) (context.Context, string) {
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	argsForCall := fake.deleteDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) DeleteDataReturns(result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	fake.deleteDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) DeleteDataReturnsOnCall(i int, result1 error) {
	fake.deleteDataMutex.Lock()
	defer fake.deleteDataMutex.Unlock()
	fake.DeleteDataStub = nil
	if fake.deleteDataReturnsOnCall == nil {
		fake.deleteDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) GetData(arg1 context.Context, arg2 string) (any, error) {
	fake.getDataMutex.Lock()
	ret, specificReturn := fake.getDataReturnsOnCall[len(fake.getDataArgsForCall)]
	fake.getDataArgsForCall = append(fake.getDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.GetDataStub
	fakeReturns := fake.getDataReturns
	fake.recordInvocation("GetData", []interface{}{arg1, arg2})
	fake.getDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetDataCallCount() int {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	return len(fake.getDataArgsForCall)
}

func (fake *FakeStorage) GetDataCalls(stub func(context.Context, string) (any, error)) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = stub
}

func (fake *FakeStorage) GetDataArgsForCall(i int) (context.Context, string) {
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	argsForCall := fake.getDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetDataReturns(result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	fake.getDataReturns = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetDataReturnsOnCall(i int, result1 any, result2 error) {
	fake.getDataMutex.Lock()
	defer fake.getDataMutex.Unlock()
	fake.GetDataStub = nil
	if fake.getDataReturnsOnCall == nil {
		fake.getDataReturnsOnCall = make(map[int]struct {
			result1 any
			result2 error
		})
	}
	fake.getDataReturnsOnCall[i] = struct {
		result1 any
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetPolicies(arg1 context.Context, arg2 *bool) ([]*storage.Policy, error) {
	fake.getPoliciesMutex.Lock()
	ret, specificReturn := fake.getPoliciesReturnsOnCall[len(fake.getPoliciesArgsForCall)]
	fake.getPoliciesArgsForCall = append(fake.getPoliciesArgsForCall, struct {
		arg1 context.Context
		arg2 *bool
	}{arg1, arg2})
	stub := fake.GetPoliciesStub
	fakeReturns := fake.getPoliciesReturns
	fake.recordInvocation("GetPolicies", []interface{}{arg1, arg2})
	fake.getPoliciesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) GetPoliciesCallCount() int {
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	return len(fake.getPoliciesArgsForCall)
}

func (fake *FakeStorage) GetPoliciesCalls(stub func(context.Context, *bool) ([]*storage.Policy, error)) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = stub
}

func (fake *FakeStorage) GetPoliciesArgsForCall(i int) (context.Context, *bool) {
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	argsForCall := fake.getPoliciesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) GetPoliciesReturns(result1 []*storage.Policy, result2 error) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = nil
	fake.getPoliciesReturns = struct {
		result1 []*storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) GetPoliciesReturnsOnCall(i int, result1 []*storage.Policy, result2 error) {
	fake.getPoliciesMutex.Lock()
	defer fake.getPoliciesMutex.Unlock()
	fake.GetPoliciesStub = nil
	if fake.getPoliciesReturnsOnCall == nil {
		fake.getPoliciesReturnsOnCall = make(map[int]struct {
			result1 []*storage.Policy
			result2 error
		})
	}
	fake.getPoliciesReturnsOnCall[i] = struct {
		result1 []*storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) ListenPolicyDataChanges(arg1 context.Context) error {
	fake.listenPolicyDataChangesMutex.Lock()
	ret, specificReturn := fake.listenPolicyDataChangesReturnsOnCall[len(fake.listenPolicyDataChangesArgsForCall)]
	fake.listenPolicyDataChangesArgsForCall = append(fake.listenPolicyDataChangesArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.ListenPolicyDataChangesStub
	fakeReturns := fake.listenPolicyDataChangesReturns
	fake.recordInvocation("ListenPolicyDataChanges", []interface{}{arg1})
	fake.listenPolicyDataChangesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) ListenPolicyDataChangesCallCount() int {
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	return len(fake.listenPolicyDataChangesArgsForCall)
}

func (fake *FakeStorage) ListenPolicyDataChangesCalls(stub func(context.Context) error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = stub
}

func (fake *FakeStorage) ListenPolicyDataChangesArgsForCall(i int) context.Context {
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	argsForCall := fake.listenPolicyDataChangesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStorage) ListenPolicyDataChangesReturns(result1 error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = nil
	fake.listenPolicyDataChangesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) ListenPolicyDataChangesReturnsOnCall(i int, result1 error) {
	fake.listenPolicyDataChangesMutex.Lock()
	defer fake.listenPolicyDataChangesMutex.Unlock()
	fake.ListenPolicyDataChangesStub = nil
	if fake.listenPolicyDataChangesReturnsOnCall == nil {
		fake.listenPolicyDataChangesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.listenPolicyDataChangesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Policy(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string) (*storage.Policy, error) {
	fake.policyMutex.Lock()
	ret, specificReturn := fake.policyReturnsOnCall[len(fake.policyArgsForCall)]
	fake.policyArgsForCall = append(fake.policyArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.PolicyStub
	fakeReturns := fake.policyReturns
	fake.recordInvocation("Policy", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.policyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) PolicyCallCount() int {
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	return len(fake.policyArgsForCall)
}

func (fake *FakeStorage) PolicyCalls(stub func(context.Context, string, string, string, string) (*storage.Policy, error)) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = stub
}

func (fake *FakeStorage) PolicyArgsForCall(i int) (context.Context, string, string, string, string) {
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	argsForCall := fake.policyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStorage) PolicyReturns(result1 *storage.Policy, result2 error) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = nil
	fake.policyReturns = struct {
		result1 *storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) PolicyReturnsOnCall(i int, result1 *storage.Policy, result2 error) {
	fake.policyMutex.Lock()
	defer fake.policyMutex.Unlock()
	fake.PolicyStub = nil
	if fake.policyReturnsOnCall == nil {
		fake.policyReturnsOnCall = make(map[int]struct {
			result1 *storage.Policy
			result2 error
		})
	}
	fake.policyReturnsOnCall[i] = struct {
		result1 *storage.Policy
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) SaveAutoImportConfig(arg1 context.Context, arg2 *storage.PolicyAutoImport) error {
	fake.saveAutoImportConfigMutex.Lock()
	ret, specificReturn := fake.saveAutoImportConfigReturnsOnCall[len(fake.saveAutoImportConfigArgsForCall)]
	fake.saveAutoImportConfigArgsForCall = append(fake.saveAutoImportConfigArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.PolicyAutoImport
	}{arg1, arg2})
	stub := fake.SaveAutoImportConfigStub
	fakeReturns := fake.saveAutoImportConfigReturns
	fake.recordInvocation("SaveAutoImportConfig", []interface{}{arg1, arg2})
	fake.saveAutoImportConfigMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SaveAutoImportConfigCallCount() int {
	fake.saveAutoImportConfigMutex.RLock()
	defer fake.saveAutoImportConfigMutex.RUnlock()
	return len(fake.saveAutoImportConfigArgsForCall)
}

func (fake *FakeStorage) SaveAutoImportConfigCalls(stub func(context.Context, *storage.PolicyAutoImport) error) {
	fake.saveAutoImportConfigMutex.Lock()
	defer fake.saveAutoImportConfigMutex.Unlock()
	fake.SaveAutoImportConfigStub = stub
}

func (fake *FakeStorage) SaveAutoImportConfigArgsForCall(i int) (context.Context, *storage.PolicyAutoImport) {
	fake.saveAutoImportConfigMutex.RLock()
	defer fake.saveAutoImportConfigMutex.RUnlock()
	argsForCall := fake.saveAutoImportConfigArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) SaveAutoImportConfigReturns(result1 error) {
	fake.saveAutoImportConfigMutex.Lock()
	defer fake.saveAutoImportConfigMutex.Unlock()
	fake.SaveAutoImportConfigStub = nil
	fake.saveAutoImportConfigReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SaveAutoImportConfigReturnsOnCall(i int, result1 error) {
	fake.saveAutoImportConfigMutex.Lock()
	defer fake.saveAutoImportConfigMutex.Unlock()
	fake.SaveAutoImportConfigStub = nil
	if fake.saveAutoImportConfigReturnsOnCall == nil {
		fake.saveAutoImportConfigReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveAutoImportConfigReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SavePolicy(arg1 context.Context, arg2 *storage.Policy) error {
	fake.savePolicyMutex.Lock()
	ret, specificReturn := fake.savePolicyReturnsOnCall[len(fake.savePolicyArgsForCall)]
	fake.savePolicyArgsForCall = append(fake.savePolicyArgsForCall, struct {
		arg1 context.Context
		arg2 *storage.Policy
	}{arg1, arg2})
	stub := fake.SavePolicyStub
	fakeReturns := fake.savePolicyReturns
	fake.recordInvocation("SavePolicy", []interface{}{arg1, arg2})
	fake.savePolicyMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SavePolicyCallCount() int {
	fake.savePolicyMutex.RLock()
	defer fake.savePolicyMutex.RUnlock()
	return len(fake.savePolicyArgsForCall)
}

func (fake *FakeStorage) SavePolicyCalls(stub func(context.Context, *storage.Policy) error) {
	fake.savePolicyMutex.Lock()
	defer fake.savePolicyMutex.Unlock()
	fake.SavePolicyStub = stub
}

func (fake *FakeStorage) SavePolicyArgsForCall(i int) (context.Context, *storage.Policy) {
	fake.savePolicyMutex.RLock()
	defer fake.savePolicyMutex.RUnlock()
	argsForCall := fake.savePolicyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStorage) SavePolicyReturns(result1 error) {
	fake.savePolicyMutex.Lock()
	defer fake.savePolicyMutex.Unlock()
	fake.SavePolicyStub = nil
	fake.savePolicyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SavePolicyReturnsOnCall(i int, result1 error) {
	fake.savePolicyMutex.Lock()
	defer fake.savePolicyMutex.Unlock()
	fake.SavePolicyStub = nil
	if fake.savePolicyReturnsOnCall == nil {
		fake.savePolicyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.savePolicyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetData(arg1 context.Context, arg2 string, arg3 map[string]interface{}) error {
	fake.setDataMutex.Lock()
	ret, specificReturn := fake.setDataReturnsOnCall[len(fake.setDataArgsForCall)]
	fake.setDataArgsForCall = append(fake.setDataArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 map[string]interface{}
	}{arg1, arg2, arg3})
	stub := fake.SetDataStub
	fakeReturns := fake.setDataReturns
	fake.recordInvocation("SetData", []interface{}{arg1, arg2, arg3})
	fake.setDataMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SetDataCallCount() int {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	return len(fake.setDataArgsForCall)
}

func (fake *FakeStorage) SetDataCalls(stub func(context.Context, string, map[string]interface{}) error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = stub
}

func (fake *FakeStorage) SetDataArgsForCall(i int) (context.Context, string, map[string]interface{}) {
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	argsForCall := fake.setDataArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStorage) SetDataReturns(result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	fake.setDataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetDataReturnsOnCall(i int, result1 error) {
	fake.setDataMutex.Lock()
	defer fake.setDataMutex.Unlock()
	fake.SetDataStub = nil
	if fake.setDataReturnsOnCall == nil {
		fake.setDataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setDataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetPolicyLock(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 bool) error {
	fake.setPolicyLockMutex.Lock()
	ret, specificReturn := fake.setPolicyLockReturnsOnCall[len(fake.setPolicyLockArgsForCall)]
	fake.setPolicyLockArgsForCall = append(fake.setPolicyLockArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 bool
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.SetPolicyLockStub
	fakeReturns := fake.setPolicyLockReturns
	fake.recordInvocation("SetPolicyLock", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.setPolicyLockMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStorage) SetPolicyLockCallCount() int {
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	return len(fake.setPolicyLockArgsForCall)
}

func (fake *FakeStorage) SetPolicyLockCalls(stub func(context.Context, string, string, string, string, bool) error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = stub
}

func (fake *FakeStorage) SetPolicyLockArgsForCall(i int) (context.Context, string, string, string, string, bool) {
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	argsForCall := fake.setPolicyLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeStorage) SetPolicyLockReturns(result1 error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = nil
	fake.setPolicyLockReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) SetPolicyLockReturnsOnCall(i int, result1 error) {
	fake.setPolicyLockMutex.Lock()
	defer fake.setPolicyLockMutex.Unlock()
	fake.SetPolicyLockStub = nil
	if fake.setPolicyLockReturnsOnCall == nil {
		fake.setPolicyLockReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setPolicyLockReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStorage) Subscriber(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 string, arg7 string) (*storage.Subscriber, error) {
	fake.subscriberMutex.Lock()
	ret, specificReturn := fake.subscriberReturnsOnCall[len(fake.subscriberArgsForCall)]
	fake.subscriberArgsForCall = append(fake.subscriberArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 string
		arg7 string
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	stub := fake.SubscriberStub
	fakeReturns := fake.subscriberReturns
	fake.recordInvocation("Subscriber", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7})
	fake.subscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStorage) SubscriberCallCount() int {
	fake.subscriberMutex.RLock()
	defer fake.subscriberMutex.RUnlock()
	return len(fake.subscriberArgsForCall)
}

func (fake *FakeStorage) SubscriberCalls(stub func(context.Context, string, string, string, string, string, string) (*storage.Subscriber, error)) {
	fake.subscriberMutex.Lock()
	defer fake.subscriberMutex.Unlock()
	fake.SubscriberStub = stub
}

func (fake *FakeStorage) SubscriberArgsForCall(i int) (context.Context, string, string, string, string, string, string) {
	fake.subscriberMutex.RLock()
	defer fake.subscriberMutex.RUnlock()
	argsForCall := fake.subscriberArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeStorage) SubscriberReturns(result1 *storage.Subscriber, result2 error) {
	fake.subscriberMutex.Lock()
	defer fake.subscriberMutex.Unlock()
	fake.SubscriberStub = nil
	fake.subscriberReturns = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) SubscriberReturnsOnCall(i int, result1 *storage.Subscriber, result2 error) {
	fake.subscriberMutex.Lock()
	defer fake.subscriberMutex.Unlock()
	fake.SubscriberStub = nil
	if fake.subscriberReturnsOnCall == nil {
		fake.subscriberReturnsOnCall = make(map[int]struct {
			result1 *storage.Subscriber
			result2 error
		})
	}
	fake.subscriberReturnsOnCall[i] = struct {
		result1 *storage.Subscriber
		result2 error
	}{result1, result2}
}

func (fake *FakeStorage) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.activeImportConfigsMutex.RLock()
	defer fake.activeImportConfigsMutex.RUnlock()
	fake.addPolicySubscribersMutex.RLock()
	defer fake.addPolicySubscribersMutex.RUnlock()
	fake.autoImportConfigMutex.RLock()
	defer fake.autoImportConfigMutex.RUnlock()
	fake.autoImportConfigsMutex.RLock()
	defer fake.autoImportConfigsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.createSubscriberMutex.RLock()
	defer fake.createSubscriberMutex.RUnlock()
	fake.deleteAutoImportConfigMutex.RLock()
	defer fake.deleteAutoImportConfigMutex.RUnlock()
	fake.deleteDataMutex.RLock()
	defer fake.deleteDataMutex.RUnlock()
	fake.getDataMutex.RLock()
	defer fake.getDataMutex.RUnlock()
	fake.getPoliciesMutex.RLock()
	defer fake.getPoliciesMutex.RUnlock()
	fake.listenPolicyDataChangesMutex.RLock()
	defer fake.listenPolicyDataChangesMutex.RUnlock()
	fake.policyMutex.RLock()
	defer fake.policyMutex.RUnlock()
	fake.saveAutoImportConfigMutex.RLock()
	defer fake.saveAutoImportConfigMutex.RUnlock()
	fake.savePolicyMutex.RLock()
	defer fake.savePolicyMutex.RUnlock()
	fake.setDataMutex.RLock()
	defer fake.setDataMutex.RUnlock()
	fake.setPolicyLockMutex.RLock()
	defer fake.setPolicyLockMutex.RUnlock()
	fake.subscriberMutex.RLock()
	defer fake.subscriberMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStorage) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ policy.Storage = new(FakeStorage)
